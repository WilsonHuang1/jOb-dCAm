/**
 * Orbbec Gemini 335 - Stereo IR Camera Parameter Extractor
 * This extracts the specific parameters needed for stereo SLAM:
 * - Left IR camera intrinsics and distortion
 * - Right IR camera intrinsics and distortion  
 * - Stereo extrinsics (transformation between left and right IR cameras)
 * - IMU parameters and extrinsics relative to IR cameras
 */

#include <iostream>
#include <fstream>
#include <iomanip>
#include <cmath>
#include <libobsensor/ObSensor.hpp>

void printIRCameraIntrinsics(const OBCameraIntrinsic& intrinsic, const std::string& cameraName) {
    std::cout << "\n" << cameraName << " IR Camera Intrinsics:" << std::endl;
    std::cout << std::fixed << std::setprecision(6);
    std::cout << "  Focal Length (fx, fy): (" << intrinsic.fx << ", " << intrinsic.fy << ")" << std::endl;
    std::cout << "  Principal Point (cx, cy): (" << intrinsic.cx << ", " << intrinsic.cy << ")" << std::endl;
    std::cout << "  Image Resolution (width, height): (" << intrinsic.width << ", " << intrinsic.height << ")" << std::endl;
}

void printIRCameraDistortion(const OBCameraDistortion& distortion, const std::string& cameraName) {
    std::cout << "\n" << cameraName << " IR Camera Distortion:" << std::endl;
    std::cout << std::fixed << std::setprecision(6);
    std::cout << "  Model: ";
    switch(distortion.model) {
        case OB_DISTORTION_BROWN_CONRADY:
            std::cout << "Brown-Conrady";
            break;
        case OB_DISTORTION_INVERSE_BROWN_CONRADY:
            std::cout << "Inverse Brown-Conrady";
            break;
        case OB_DISTORTION_KANNALA_BRANDT4:
            std::cout << "Kannala-Brandt4";
            break;
        case OB_DISTORTION_MODIFIED_BROWN_CONRADY:
            std::cout << "Modified Brown-Conrady";
            break;
        case OB_DISTORTION_BROWN_CONRADY_K6:
            std::cout << "Brown-Conrady K6";
            break;
        default:
            std::cout << "Unknown (" << distortion.model << ")";
            break;
    }
    std::cout << std::endl;
    std::cout << "  Coefficients:" << std::endl;
    std::cout << "    k1=" << distortion.k1 << ", k2=" << distortion.k2 << ", k3=" << distortion.k3 << std::endl;
    std::cout << "    k4=" << distortion.k4 << ", k5=" << distortion.k5 << ", k6=" << distortion.k6 << std::endl;
    std::cout << "    p1=" << distortion.p1 << ", p2=" << distortion.p2 << std::endl;
}

void printExtrinsics(const OBExtrinsic& extrinsic, const std::string& fromSensor, const std::string& toSensor) {
    std::cout << "\n" << fromSensor << " to " << toSensor << " Extrinsics:" << std::endl;
    std::cout << std::fixed << std::setprecision(6);
    std::cout << "  Rotation Matrix:" << std::endl;
    for (int i = 0; i < 3; i++) {
        std::cout << "  [";
        for (int j = 0; j < 3; j++) {
            std::cout << std::setw(10) << extrinsic.rot[i*3 + j];
            if (j < 2) std::cout << ", ";
        }
        std::cout << "]" << std::endl;
    }
    std::cout << "  Translation Vector (x, y, z): [";
    std::cout << extrinsic.trans[0] << ", " << extrinsic.trans[1] << ", " << extrinsic.trans[2] << "] (mm)" << std::endl;
    
    // Calculate baseline for stereo
    if (fromSensor.find("Left") != std::string::npos && toSensor.find("Right") != std::string::npos) {
        float baseline = sqrt(extrinsic.trans[0]*extrinsic.trans[0] + 
                             extrinsic.trans[1]*extrinsic.trans[1] + 
                             extrinsic.trans[2]*extrinsic.trans[2]);
        std::cout << "  Stereo Baseline: " << baseline << " mm (" << baseline/1000.0 << " m)" << std::endl;
    }
}

void saveIRStereoParametersToFile(const std::string& filename,
                                  const OBCameraIntrinsic& leftIRIntrinsic, const OBCameraDistortion& leftIRDistortion,
                                  const OBCameraIntrinsic& rightIRIntrinsic, const OBCameraDistortion& rightIRDistortion,
                                  const OBExtrinsic& leftToRightIR,
                                  const OBAccelIntrinsic& accelIntrinsic, const OBGyroIntrinsic& gyroIntrinsic,
                                  const OBExtrinsic& leftIRToAccel, const OBExtrinsic& leftIRToGyro,
                                  bool hasIMU) {
    
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file for writing: " << filename << std::endl;
        return;
    }

    file << "# Orbbec Gemini 335 - Stereo IR Camera and IMU Parameters" << std::endl;
    file << "# Generated by Orbbec Stereo Parameter Extractor" << std::endl;
    file << "# Based on OrbbecSDK v2.4.8" << std::endl;
    file << std::endl;

    // ORB-SLAM3 Stereo YAML format
    file << "#--------------------------------------------------------------------------------------------" << std::endl;
    file << "# Camera Parameters for Orbbec Gemini 335 - Stereo Mode (IR Left + IR Right)" << std::endl;
    file << "#--------------------------------------------------------------------------------------------" << std::endl;
    file << std::endl;

    file << "# Camera type: 1 -> Pinhole, 2 -> KannalaBrandt8 (for wide-angle), 3 -> Rectified" << std::endl;
    file << "Camera.type: 1" << std::endl;
    file << std::endl;

    // Left IR Camera intrinsics
    file << "# Left IR Camera intrinsic parameters" << std::endl;
    file << "Camera.fx: " << leftIRIntrinsic.fx << std::endl;
    file << "Camera.fy: " << leftIRIntrinsic.fy << std::endl;
    file << "Camera.cx: " << leftIRIntrinsic.cx << std::endl;
    file << "Camera.cy: " << leftIRIntrinsic.cy << std::endl;
    file << std::endl;

    // Left IR Camera distortion
    file << "# Distortion coefficients (k1, k2, p1, p2, k3)" << std::endl;
    file << "Camera.k1: " << leftIRDistortion.k1 << std::endl;
    file << "Camera.k2: " << leftIRDistortion.k2 << std::endl;
    file << "Camera.p1: " << leftIRDistortion.p1 << std::endl;
    file << "Camera.p2: " << leftIRDistortion.p2 << std::endl;
    file << "Camera.k3: " << leftIRDistortion.k3 << std::endl;
    file << std::endl;

    // Right IR Camera intrinsics
    file << "# Right IR Camera intrinsic parameters" << std::endl;
    file << "Camera.fx_: " << rightIRIntrinsic.fx << std::endl;
    file << "Camera.fy_: " << rightIRIntrinsic.fy << std::endl;
    file << "Camera.cx_: " << rightIRIntrinsic.cx << std::endl;
    file << "Camera.cy_: " << rightIRIntrinsic.cy << std::endl;
    file << std::endl;

    // Right IR Camera distortion
    file << "# Right camera distortion coefficients" << std::endl;
    file << "Camera.k1_: " << rightIRDistortion.k1 << std::endl;
    file << "Camera.k2_: " << rightIRDistortion.k2 << std::endl;
    file << "Camera.p1_: " << rightIRDistortion.p1 << std::endl;
    file << "Camera.p2_: " << rightIRDistortion.p2 << std::endl;
    file << "Camera.k3_: " << rightIRDistortion.k3 << std::endl;
    file << std::endl;

    // Stereo baseline
    float baseline = sqrt(leftToRightIR.trans[0]*leftToRightIR.trans[0] + 
                         leftToRightIR.trans[1]*leftToRightIR.trans[1] + 
                         leftToRightIR.trans[2]*leftToRightIR.trans[2]);
    file << "# Stereo baseline (distance between cameras in meters)" << std::endl;
    file << "Camera.baseline: " << baseline/1000.0 << std::endl;
    file << std::endl;

    // Transformation matrix (left to right IR)
    file << "# Transformation from left IR to right IR camera" << std::endl;
    file << "Camera.T_c1_c2: !!opencv-matrix" << std::endl;
    file << "   rows: 4" << std::endl;
    file << "   cols: 4" << std::endl;
    file << "   dt: f" << std::endl;
    file << "   data: [";
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            file << leftToRightIR.rot[i*3 + j];
            if (!(i == 2 && j == 2)) file << ", ";
        }
        file << ", " << leftToRightIR.trans[i]/1000.0; // Convert mm to m
        if (i < 2) file << "," << std::endl << "          ";
    }
    file << "," << std::endl << "          0.0, 0.0, 0.0, 1.0]" << std::endl;
    file << std::endl;

    // Camera dimensions
    file << "# Camera image dimensions" << std::endl;
    file << "Camera.width: " << leftIRIntrinsic.width << std::endl;
    file << "Camera.height: " << leftIRIntrinsic.height << std::endl;
    file << std::endl;

    file << "# Camera frames per second " << std::endl;
    file << "Camera.fps: 30.0" << std::endl;
    file << std::endl;

    file << "# Color RGB encoding (1 for RGB, 0 for BGR)" << std::endl;
    file << "Camera.RGB: 0" << std::endl;
    file << std::endl;

    // IMU parameters if available
    if (hasIMU) {
        file << "#--------------------------------------------------------------------------------------------" << std::endl;
        file << "# IMU Parameters" << std::endl;
        file << "#--------------------------------------------------------------------------------------------" << std::endl;
        file << std::endl;

        file << "# IMU noise characteristics" << std::endl;
        file << "IMU.NoiseGyro: " << gyroIntrinsic.noiseDensity << "  # rad/s/sqrt(Hz)" << std::endl;
        file << "IMU.NoiseAcc: " << accelIntrinsic.noiseDensity << "  # m/s^2/sqrt(Hz)" << std::endl;
        file << "IMU.GyroWalk: " << gyroIntrinsic.randomWalk << "  # rad/s^2/sqrt(Hz)" << std::endl;
        file << "IMU.AccWalk: " << accelIntrinsic.randomWalk << "  # m/s^3/sqrt(Hz)" << std::endl;
        file << "IMU.Frequency: 200  # Hz" << std::endl;
        file << std::endl;

        // Camera-IMU extrinsics (left IR to IMU)
        file << "# Transformation from left IR camera to IMU body frame" << std::endl;
        file << "IMU.T_b_c1: !!opencv-matrix" << std::endl;
        file << "   rows: 4" << std::endl;
        file << "   cols: 4" << std::endl;
        file << "   dt: f" << std::endl;
        file << "   data: [";
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                file << leftIRToAccel.rot[i*3 + j];
                if (!(i == 2 && j == 2)) file << ", ";
            }
            file << ", " << leftIRToAccel.trans[i]/1000.0; // Convert mm to m
            if (i < 2) file << "," << std::endl << "          ";
        }
        file << "," << std::endl << "          0.0, 0.0, 0.0, 1.0]" << std::endl;
        file << std::endl;
    }

    // ORB Features section
    file << "#--------------------------------------------------------------------------------------------" << std::endl;
    file << "# ORB Features" << std::endl;
    file << "#--------------------------------------------------------------------------------------------" << std::endl;
    file << std::endl;
    file << "ORBextractor.nFeatures: 1200" << std::endl;
    file << "ORBextractor.scaleFactor: 1.2" << std::endl;
    file << "ORBextractor.nLevels: 8" << std::endl;
    file << "ORBextractor.iniThFAST: 20" << std::endl;
    file << "ORBextractor.minThFAST: 7" << std::endl;
    file << std::endl;

    // Stereo parameters
    file << "#--------------------------------------------------------------------------------------------" << std::endl;
    file << "# Stereo Parameters" << std::endl;
    file << "#--------------------------------------------------------------------------------------------" << std::endl;
    file << std::endl;
    file << "Stereo.ThDepth: 35.0" << std::endl;
    file << "Stereo.FarThr: 6000.0" << std::endl;
    file << std::endl;

    // Viewer parameters
    file << "#--------------------------------------------------------------------------------------------" << std::endl;
    file << "# Viewer Parameters" << std::endl;
    file << "#--------------------------------------------------------------------------------------------" << std::endl;
    file << std::endl;
    file << "Viewer.KeyFrameSize: 0.05" << std::endl;
    file << "Viewer.KeyFrameLineWidth: 1.0" << std::endl;
    file << "Viewer.GraphLineWidth: 0.9" << std::endl;
    file << "Viewer.PointSize: 2.0" << std::endl;
    file << "Viewer.CameraSize: 0.08" << std::endl;
    file << "Viewer.CameraLineWidth: 3.0" << std::endl;
    file << "Viewer.ViewpointX: 0.0" << std::endl;
    file << "Viewer.ViewpointY: -0.7" << std::endl;
    file << "Viewer.ViewpointZ: -1.8" << std::endl;
    file << "Viewer.ViewpointF: 500.0" << std::endl;

    file.close();
    std::cout << "\nStereo parameters saved to: " << filename << std::endl;
}

int main() try {
    std::cout << "=== Orbbec Gemini 335 - Stereo IR Parameter Extractor ===" << std::endl;
    std::cout << "Based on OrbbecSDK v2.4.8" << std::endl;
    std::cout << "=================================================" << std::endl;

    // Create context and get device
    ob::Context context;
    auto deviceList = context.queryDeviceList();
    
    if (deviceList->getCount() == 0) {
        std::cerr << "No Orbbec device found!" << std::endl;
        return -1;
    }
    
    auto device = deviceList->getDevice(0);
    auto deviceInfo = device->getDeviceInfo();
    
    std::cout << "Device found: " << deviceInfo->name() << std::endl;
    std::cout << "Serial Number: " << deviceInfo->serialNumber() << std::endl;
    std::cout << "Firmware Version: " << deviceInfo->firmwareVersion() << std::endl;
    std::cout << "=================================================" << std::endl;

    // Create pipeline for IR cameras
    ob::Pipeline pipeline(device);
    auto config = std::make_shared<ob::Config>();

    // Check available sensors
    auto sensorList = device->getSensorList();
    bool hasLeftIR = false, hasRightIR = false, hasIMU = false;
    
    for (uint32_t i = 0; i < sensorList->getCount(); i++) {
        auto sensorType = sensorList->getSensorType(i);
        if (sensorType == OB_SENSOR_IR_LEFT) hasLeftIR = true;
        if (sensorType == OB_SENSOR_IR_RIGHT) hasRightIR = true;
        if (sensorType == OB_SENSOR_ACCEL || sensorType == OB_SENSOR_GYRO) hasIMU = true;
    }

    if (!hasLeftIR || !hasRightIR) {
        std::cerr << "ERROR: Device does not support stereo IR cameras!" << std::endl;
        std::cerr << "Left IR: " << (hasLeftIR ? "Available" : "Missing") << std::endl;
        std::cerr << "Right IR: " << (hasRightIR ? "Available" : "Missing") << std::endl;
        return -1;
    }

    // Enable IR streams
    config->enableVideoStream(OB_STREAM_IR_LEFT, 640, 480, 30, OB_FORMAT_Y8);
    config->enableVideoStream(OB_STREAM_IR_RIGHT, 640, 480, 30, OB_FORMAT_Y8);

    std::cout << "IR stereo streams configured" << std::endl;
    
    // Start pipeline to get calibration data
    pipeline.start(config);
    std::cout << "Pipeline started, extracting calibration parameters..." << std::endl;

    // Wait for frames to ensure calibration data is available
    auto frameset = pipeline.waitForFrameset(1000);
    if (!frameset) {
        std::cerr << "Failed to get frameset for calibration" << std::endl;
        return -1;
    }

    std::cout << "Frames received, extracting parameters..." << std::endl;
    std::cout << "=================================================" << std::endl;

    // Get camera calibration parameters
    auto cameraParams = pipeline.getCameraParam();
    
    // Try to get IR-specific calibration using the config
    OBCalibrationParam calibrationParams;
    try {
        calibrationParams = pipeline.getCalibrationParam(config);
    } catch (const ob::Error& e) {
        std::cout << "Warning: Could not get detailed calibration parameters: " << e.getMessage() << std::endl;
        std::cout << "Falling back to basic camera parameters..." << std::endl;
        
        // Fallback: Use basic camera parameters and try to get stream profiles
        auto leftProfiles = pipeline.getStreamProfileList(OB_SENSOR_IR_LEFT);
        auto rightProfiles = pipeline.getStreamProfileList(OB_SENSOR_IR_RIGHT);
        
        if (leftProfiles->getCount() == 0 || rightProfiles->getCount() == 0) {
            std::cerr << "ERROR: Could not get IR stream profiles!" << std::endl;
            return -1;
        }
        
        auto leftProfile = leftProfiles->getProfile(0)->as<ob::VideoStreamProfile>();
        auto rightProfile = rightProfiles->getProfile(0)->as<ob::VideoStreamProfile>();
        
        try {
            auto leftIntrinsic = leftProfile->getIntrinsic();
            auto rightIntrinsic = rightProfile->getIntrinsic();
            auto extrinsic = leftProfile->getExtrinsicTo(rightProfile);
            
            std::cout << "\n=== IR STEREO CAMERA PARAMETERS (from stream profiles) ===" << std::endl;
            printIRCameraIntrinsics(leftIntrinsic, "Left");
            printIRCameraIntrinsics(rightIntrinsic, "Right");
            
            // Create basic distortion (assuming no distortion)
            OBCameraDistortion noDistortion = {};
            printIRCameraDistortion(noDistortion, "Left (No Distortion Data)");
            printIRCameraDistortion(noDistortion, "Right (No Distortion Data)");
            
            printExtrinsics(extrinsic, "Left IR", "Right IR");
            
            // Save basic parameters
            std::cout << "\n=== SAVING BASIC PARAMETERS ===" << std::endl;
            saveIRStereoParametersToFile("Orbbec_Gemini335_Stereo_Basic.yaml",
                                        leftIntrinsic, noDistortion,
                                        rightIntrinsic, noDistortion,
                                        extrinsic,
                                        {}, {},  // Empty IMU params
                                        {}, {},  // Empty extrinsics
                                        false);  // No IMU
            
            pipeline.stop();
            std::cout << "Basic stereo IR parameter extraction completed!" << std::endl;
            std::cout << "Note: Distortion and IMU parameters are not available." << std::endl;
            std::cout << "You may need to calibrate manually for better accuracy." << std::endl;
            return 0;
            
        } catch (const ob::Error& e2) {
            std::cerr << "ERROR: Could not get intrinsics from stream profiles: " << e2.getMessage() << std::endl;
            return -1;
        }
    }
    
    // Extract left and right IR parameters from detailed calibration
    OBCameraIntrinsic leftIRIntrinsic = calibrationParams.intrinsics[OB_SENSOR_IR_LEFT];
    OBCameraIntrinsic rightIRIntrinsic = calibrationParams.intrinsics[OB_SENSOR_IR_RIGHT];
    
    OBCameraDistortion leftIRDistortion = calibrationParams.distortion[OB_SENSOR_IR_LEFT];
    OBCameraDistortion rightIRDistortion = calibrationParams.distortion[OB_SENSOR_IR_RIGHT];
    
    // Get extrinsics between left and right IR cameras
    OBExtrinsic leftToRightIR = calibrationParams.extrinsics[OB_SENSOR_IR_LEFT][OB_SENSOR_IR_RIGHT];

    std::cout << "=== IR STEREO CAMERA PARAMETERS ===" << std::endl;
    printIRCameraIntrinsics(leftIRIntrinsic, "Left");
    printIRCameraIntrinsics(rightIRIntrinsic, "Right");
    
    printIRCameraDistortion(leftIRDistortion, "Left");
    printIRCameraDistortion(rightIRDistortion, "Right");
    
    printExtrinsics(leftToRightIR, "Left IR", "Right IR");

    // Get IMU parameters if available
    OBAccelIntrinsic accelIntrinsic = {};
    OBGyroIntrinsic gyroIntrinsic = {};
    OBExtrinsic leftIRToAccel = {};
    OBExtrinsic leftIRToGyro = {};
    
    if (hasIMU) {
        std::cout << "\n=== IMU PARAMETERS ===" << std::endl;
        try {
            // Try to get IMU intrinsics from device properties
            // Note: These methods may not be available in all SDK versions
            // We'll use default values and note that manual calibration may be needed
            
            std::cout << "IMU detected, but intrinsic parameters need manual calibration" << std::endl;
            std::cout << "Using default noise characteristics (please calibrate manually):" << std::endl;
            
            // Set reasonable default values that user should calibrate
            accelIntrinsic.noiseDensity = 0.0028f;  // Default from documentation
            accelIntrinsic.randomWalk = 0.00008f;
            gyroIntrinsic.noiseDensity = 0.00016f;
            gyroIntrinsic.randomWalk = 0.000002f;
            
            std::cout << "Accelerometer (DEFAULT - CALIBRATE MANUALLY):" << std::endl;
            std::cout << "  Noise Density: " << accelIntrinsic.noiseDensity << std::endl;
            std::cout << "  Random Walk: " << accelIntrinsic.randomWalk << std::endl;
            
            std::cout << "Gyroscope (DEFAULT - CALIBRATE MANUALLY):" << std::endl;
            std::cout << "  Noise Density: " << gyroIntrinsic.noiseDensity << std::endl;
            std::cout << "  Random Walk: " << gyroIntrinsic.randomWalk << std::endl;
            
            // Get camera-IMU extrinsics
            leftIRToAccel = calibrationParams.extrinsics[OB_SENSOR_IR_LEFT][OB_SENSOR_ACCEL];
            leftIRToGyro = calibrationParams.extrinsics[OB_SENSOR_IR_LEFT][OB_SENSOR_GYRO];
            
            printExtrinsics(leftIRToAccel, "Left IR", "Accelerometer");
            printExtrinsics(leftIRToGyro, "Left IR", "Gyroscope");
            
        } catch (const ob::Error& e) {
            std::cout << "Warning: Could not get IMU parameters: " << e.getMessage() << std::endl;
            std::cout << "IMU extrinsics may need manual calibration" << std::endl;
            hasIMU = false;
        }
    }

    // Save parameters to file
    std::cout << "\n=== SAVING PARAMETERS ===" << std::endl;
    saveIRStereoParametersToFile("Orbbec_Gemini335_Stereo.yaml",
                                leftIRIntrinsic, leftIRDistortion,
                                rightIRIntrinsic, rightIRDistortion,
                                leftToRightIR,
                                accelIntrinsic, gyroIntrinsic,
                                leftIRToAccel, leftIRToGyro,
                                hasIMU);

    pipeline.stop();
    std::cout << "Stereo IR parameter extraction completed successfully!" << std::endl;
    
    return 0;
}
catch(ob::Error &e) {
    std::cerr << "OrbbecSDK Error:" << std::endl;
    std::cerr << "Function: " << e.getFunction() << std::endl;
    std::cerr << "Args: " << e.getArgs() << std::endl;
    std::cerr << "Message: " << e.what() << std::endl;
    std::cerr << "Type: " << e.getExceptionType() << std::endl;
    return EXIT_FAILURE;
}
catch(std::exception &e) {
    std::cerr << "Standard Error: " << e.what() << std::endl;
    return EXIT_FAILURE;
}